#
#  INIT-FUNCTIONS for Universal INIT with busybox
#  (C) Dieter Miosga , 2008-2014-03-31 
#
#set -x
#DELAY=delay
#
create_rootfs_dirs()
{
   local DIRS ARG
   if [ "$SYSTEMDIRECTORIES" != "" ]; then
     DIRS="$SYSTEMDIRECTORIES"
     export SYSTEMDIRECTORIES
   else
     DIRS="dev dev/input dev/usb dev/net dev/shm dev/pts dev/fd dev/block dev/disk etc etc/sysconfig etc/init.d etc/rc.d  etc/udev memory union root run sys proc bin sbin usr lib lib/modules lib/libexec tmp mnt var opt usr/bin usr/sbin usr/lib usr/libexec usr/share usr/local usr/local/bin usr/local/sbin usr/local/lib usr/local/libexec usr/local/share var/lock var/log var/run usr/share bbsymlinx"
   fi

  for ARG in $DIRS; do
   #[ -d $1/$ARG ] || /bin/busybox mkdir -p $1/$ARG  2>/dev/null
   /bin/busybox mkdir -p $1/$ARG  2>/dev/null
  done

}
#
build_rootfs()
{
  /bin/busybox mkdir -p -m 0755 /dev
  /bin/busybox mkdir -p -m 0700 /root
  [ -e /dev/console ] || /bin/busybox  mknod -m 0700 /dev/console c 5 1
  [ -e /dev/null ]    || /bin/busybox  mknod /dev/null c 1 3
  > /dev/.initramfs-tools
  /bin/busybox mkdir -p /dev/.initramfs
  create_rootfs_dirs ""
  
}
#
bbversion_check()
{
  local BBVER BBMAXVER BBMINVER
  BBVER=`echo $(/bin/busybox  2>/dev/null) | /bin/busybox cut -f2 -d " " 2>/dev/null | /bin/busybox cut -c2-63   2>/dev/null `
  BBMAXVER=`echo $BBVER | /bin/busybox cut -f1 -d.`
  BBMINVER=`echo $BBVER | /bin/busybox cut -f2 -d.`
  if [ $BBMINVER -lt 15 -o $BBMAXVER -lt 1 ]; then  
    export ECHOTEXT="$ECHOTEXT
$INITPREF Wrong version $BBVER of BusyBox , must be greater or equal 1.15!"
    SYSERRPROMPT=yes
    error2ash "fatal version error"
  fi
  return 0
}
#
set_bbsymlinks()
{
  # now create symlinks 
  cd /bin
  /bin/busybox  --install -s
  cd /
  /bin/busybox ln -sf /bin/busybox /bin/sh  2>/dev/null
  #if [ -e /sbin/busybox ]; then /bin/busybox rm  /sbin/busybox  2>/dev/null ;fi
  /bin/busybox sync 2>/dev/null
}
#
# optimizes any binary executable, for that a replacement with
# an extension for local processor is present 
cmdset_optimize()
{
  # $1 = calling function id, $2 = executable to optimize
  # set arch optimization variables
  if [ "$CPUINFO" = "" ]; then 
     ECHOTEXT="$ECHOTEXT
$1 No cpu information "
     export ECHOTEXT="$ECHOTEXT
$1 missing CPU information from /proc/cpuinfo - continuing with default '$2'"          
     return 1
  fi
  if [ "$MAXCMDSET" =  "" ]; then 
     ECHOTEXT="$ECHOTEXT
$1 nothing optimized (1)"
     export ECHOTEXT="$ECHOTEXT
$1 missing processor commandset information - continuing with default '$2'"
     return 1 
  fi
  #set -x     
  ECHOTEXT="$ECHOTEXT
$1 Running on a machine '$CPUMODEL'"
  export ECHOTEXT="$ECHOTEXT
$1 capable for processor instructions '$MAXCMDSET' "
  if [ "$EXTENDU" =  "" ]; then 
    ECHOTEXT="$ECHOTEXT
$1 nothing optimized (1) processor characteristics not discovered"
    export ECHOTEXT="$ECHOTEXT
$1 missing file-extension/cpu-abbreviation - continuing with default '$2'"
    return 1 
  fi
  export ECHOTEXT="$ECHOTEXT
$1 with processor specification '$EXTENDU'"
  if [ "$2" = "" ]; then 
    ECHOTEXT="$ECHOTEXT
$1 nothing optimized (5) "
    export ECHOTEXT="$ECHOTEXT
$1 missing executable specification - continuing with default"
    return 5 
  fi                                         
  local XUTABLE
  XUTABLE="$2"
  #  and install the right one version of executable  if existent
  if [ "$(/bin/busybox ls -1 $XUTABLE-$EXTENDU 2>/dev/null)" != "" ]; then  
    ECHOTEXT="$ECHOTEXT 
$1 found '$XUTABLE' and optimizing it ..."
    # save original version
    /bin/busybox cp -af $XUTABLE $XUTABLE_native  2>/dev/null
    # replace with optimized
    /bin/busybox mv  -f $XUTABLE-$EXTENDU $XUTABLE  2>/dev/null
    # save optimzed actual version
    /bin/busybox cp -af $XUTABLE-$EXTENDU $XUTABLE_optimized  2>/dev/null
    ECHOTEXT="$ECHOTEXT 
$1 ...done: optimized '$XUTABLE' for '$ARCH' architecture" 
    ECHOTEXT="$ECHOTEXT 
$1 and '$CPUMODEL' "
    export ECHOTEXT="$ECHOTEXT 
$1 with '$MAXCMDSET'  extension"
    /bin/busybox rm $XUTABLE-*  2>/dev/null
    #set +x
    return 0
  fi
  ECHOTEXT="$ECHOTEXT 
$1 nothing optimized (127)"
  export ECHOTEXT="$ECHOTEXT 
$1 '$XUTABLE-$EXTENDU' file not found, continuing with default "
  #set +x
  return 127

}
#
set_shellvariables()
{
  #  generate the variables for reading cmdline into shell variables
  # this transforms names in a variable of the form  "a b= c d="
  # to the processable variable declarations    A=$a B=$b C=$c D=$d 
  if [ "$SHELLVARIABLES" = "" ]; then
    echoconsole "$1" " Can not set variables for shell," 
    echoconsole "$1" " No variables specified in yainitdefaults !"
    return 255
  fi
  local VAR HVAR SHELLVARNAMES TOEVAL SHELLVARSTRING
  VAR=""
  HVAR=""
  SHELLVARSTRING=""
  # check for duplicates, uppercases and nonexistent positives ( no no-prefix)
  for VAR in $SHELLVARIABLES; do
    HVAR="$(echo $VAR | /bin/busybox tr  [:upper:] [:lower:] 2>/dev/null)"
    # for all NO*  parameters do truncate NO and take the rest as new parameter
    if `is_substring_of  " $HVAR " " $SHELLVARSTRING "`; then        
      SHELLVARSTRING="$HVAR $SHELLVARSTRING"
    fi
    # for every parameter starting with 'no', create a positive one too 
    case $HVAR in
      no*)
        HVAR="$(echo $HVAR | /bin/busybox cut -c 3- 2>/dev/null)"
        if `is_substring_of  " $HVAR " " $SHELLVARSTRING "`; then        
           SHELLVARSTRING="$HVAR $SHELLVARSTRING"
        fi
      ;;
    esac   
  done
  
  #echo "# variables for cmdline recognition in linux shell" >> shellvars

  SHELLVARNAMES=""
  TOEVAL=""
  #  root=abcde --> $root --> ROOT=$root --> echo $ROOT ==> abcde
  for VAR in $SHELLVARSTRING; do
    HVAR="$(echo $VAR | /bin/busybox  cut -f1 -d '=' 2>/dev/null)"
    #if [ "$VAR" != "$HVAR" ]; then 
    VAR=$HVAR
    #fi
    HVAR="$(echo $VAR | /bin/busybox tr [:lower:] [:upper:] 2>/dev/null)"
    # do not overwrite system variables presetting, only do it by commandline
    TOEVAL="TOEVAL=\$$HVAR"
    eval $TOEVAL
    if [ "$TOEVAL" = "" ]; then
      TOEVAL="$HVAR=\"\$$VAR\""
    else
      TOEVAL="$HVAR=\$$HVAR"
    fi
    eval $TOEVAL
    #echo "$TOEVAL" >> shellvars
    if [ "$HVAR" != "" ]; then 
      export "$HVAR"
      SHELLVARNAMES="$HVAR $SHELLVARNAMES"
    fi
  done
  
  export ALLSHELLVARS="$SHELLVARNAMES"
  
  return 0
}
#
evaluate_shellvar_aliases()
{

  if [ "$SHELLVARALIASES" != "" ]; then
    local VAR HVAR TOEVAL KVAR
    VAR=""
    HVAR=""
    KVAR=""
  
    # evaluate aliases!
    #  nocd=nodvd --> NOCD=$NODVD (<-- NODVD=$nodvd <-- nodvd=nodvd from before) 
    for VAR in $SHELLVARALIASES; do
      HVAR="$(echo $VAR | /bin/busybox  cut -f1 -d '=' 2>/dev/null  | /bin/busybox tr [:lower:] [:upper:] 2>/dev/null)"
      VAR="$(echo $VAR  | /bin/busybox  cut -f2- -d '=' 2>/dev/null | /bin/busybox tr [:lower:] [:upper:] 2>/dev/null | /bin/busybox tr ".-" "_" 2>/dev/null)"
      # is $$VAR noeval t empty? then set $HVAR
      KVAR=""
      if [ "$VAR" != "" ];then 
        eval "KVAR=\"\$$VAR\""
      fi
      if [ "$KVAR" != "" ]; then
        TOEVAL="$HVAR=\"\$$VAR\""
        #echo "$TOEVAL" >> shellvars
        eval $TOEVAL
        export "$HVAR"
      fi
    done
    
    return 0
  else
    return 255
  fi

}
#UNARYVARS=""
#SHELLVARS=""
#
read_cmdline()
{
  # this is a function to read variables from linux kernel /proc/cmdline
  # It requires the preceding set_shellvars function to generate
  # and read in the necessary variables for the init scripts
  # The discovered unary variables in the cmdline are generated
  # according a predefinition in $SHELLVARIABLES in the variable presetting for initrd
  # and will be read into running init by the source statement.
  # The code is shortened and fastened by shrinking a necessary case statement
  # to two small sections , one for dual variables (assignments) and one for
  # special assignments with assurance of the effect of denied parameters
  # by repetitively specifying with other value (the last! validates)
  # OEUVRE DE MAITRE, The ultimate solution for this problem
  # (C) Dieter Miosga <dieter.miosga@gmx.de> 2009-December-through-2014-03-31
  local ARG VAR HVAR  TOEVAL
  
  ARG=""
  VAR=""
  HVAR=""
  TOEVAL=""
  
  for ARG in `/bin/busybox  cat /proc/cmdline 2>/dev/null`  ; do
    # save root=* or boot=* or gernerally x=* parameters as variable assignments 
    # this is necessary for parameters specfied in bootmanager configuration file
    # and added contradictory ones by hand - to make the change active.
    
    #  eliminate dots by converting them to underscore. Dots do not work in shell variables.
    # is there a  tr "\"" "\\""  necessary to make recognize 
    # the blanks in between " "-delimiters as variable content for MicrosoftDirectoryNames???.
    case $ARG in
      # assign non transient cmdline parameters a well defined variable
      # the dots in unary parameters cannot be taken in a variable name => "." -> "_"
      *=*)
        VAR=`echo ${ARG//=*}  | /bin/busybox tr [:lower:] [:upper:] 2>/dev/null | /bin/busybox tr ".-" "_" 2>/dev/null`
        HVAR=${ARG#*=}
      ;;
      *)
         VAR=`echo $ARG |  /bin/busybox tr [:lower:] [:upper:] 2>/dev/null | /bin/busybox tr ".-" "_" 2>/dev/null`
         HVAR="$ARG"
         # evaluate some special cases
         case $VAR in
            0|1|2|3|4|5|6|S)
              VAR=RUNLEVEL
              HVAR=$ARG
            ;;
            NOSWAP)
              export SWAPDEV=""
            ;;
            NORESUME)
              export RESUMEDEV=""
            ;;
            DEBUG)
              export DEBUG_IS_ENABLED="debug_is_enabled"
              export EMSG=""
            ;;
            QUIET)
              export VERBOSE=""
              export EMSG="2>/dev/null"
            ;;
            VERBOSE)
              export VERBOSE=5 
              export QUIET="" 
              export EMSG=""
            ;;
            RW|RO)
              export MOUNTMODE="$HVAR"
            ;;
            NOWAIT)
              VAR=WAIT
              HVAR=0
              wait=0
              export WAITFORROOT=0 
              export SYSWAIT=0
            ;;
            NONET)
              export IP="" ip="" ETH="" WLAN=""
            ;;
            TORAM)
              copy2ram=copy2ram
              export COPY2RAM=copy2ram
            ;;
         esac
    ;;
    esac
    TOEVAL="$VAR=\"$HVAR\""
    eval   "$TOEVAL"
    export "$VAR"

  done



  if [ "$RUNLEVEL" = "" ]; then  RUNLEVEL=$DEFRUNLEVEL;  fi

  #if [ "$LOGLEVEL" = "7" ]; then DEBUG=debug; DEBUG_ENABLED=$DEBUG; fi

  # for now default logging level, switched on here


  export RUNLEVEL QUIET VERBOSE
 
  #
}
#
assign_uuidlabel()
{
  local D d
  if [ "$1" = "" ]; then echo ""; return 1; fi
  D=$1
  d=`echo $D | /bin/busybox tr [:upper:] [:lower:] 2>/dev/null`
  case $d in
     label=*)
       D="/dev/disk/by-label/${D#*=}" #`echo $D | /bin/busybox   cut -f2- -d '='  2>/dev/null`"
     ;;
     devname=*)
       D="/dev/disk/by-name/${D#*=}"  #`echo $D | /bin/busybox   cut -f2- -d '='  2>/dev/null`"
     ;;
     drvname=*)
       D="/dev/disk/by-name/${D#*=}" #`echo $D | /bin/busybox   cut -f2- -d '='  2>/dev/null`"
     ;;
     name=*)
       D="/dev/disk/by-name/${D#*=}"  #`echo $D | /bin/busybox   cut -f2- -d '='  2>/dev/null`"
     ;;
     path=*)
       D="/dev/disk/by-path/${D#*=}"  #`echo $D | /bin/busybox   cut -f2- -d '='  2>/dev/null`"
     ;;
     id=*)
       D="/dev/disk/by-id/${D#*=}" #`echo $D | /bin/busybox   cut -f2- -d '='  2>/dev/null`"
     ;;
     uuid=*)
       D="/dev/disk/by-uuid/${D#*=}" #`echo $D | /bin/busybox   cut -f2- -d '='  2>/dev/null`"
     ;;
     #$DISKID=*)
     #  D="/dev/disk/by-id/`echo $D | /bin/busybox   cut -f2- -d '='  2>/dev/null`"
     #;;
  esac
  echo $D
  return 0
}
#
assign_init_variables()
{
  
  evaluate_shellvar_aliases

  
  FROM=`assign_uuidlabel $FROM`
  
  BOOTDEV=$FROM

  INITRD=`assign_uuidlabel $INITRD`
  
  ROOTDEV=`assign_uuidlabel $ROOT`

  DATADEV=`assign_uuidlabel $DATA`

  RESUMEDEV=`assign_uuidlabel $RESUME`

  SWAPDEV=`assign_uuidlabel $SWAP`

  if [ "$SGNFILE" = "" ]; then
      SGNFILE=livecd.sgn
  fi

  #CHANGES=`assign_uuidlabel $CHANGES`

  #AUTOCMD=`echo $AUTOEXEC | /bin/busybox   tr "~" " "`

  INITCMD=$INIT
  export FROM BOOTDEV INITRD ROOTDEV DATADEV RESUMEDEV SWAPDEV INITCMD
  
  
}
#
mount_procfs_sysfs()
{
  local MOUNTED

  export PATH=$PATH:/usr/sbin:/usr/bin:/sbin:/bin:/:.
  MOUNTED=""

  if [ -e /proc/mounts ]; then
    MOUNTED=`/bin/busybox cat /proc/mounts 2>/dev/null`
  else
    MOUNTED=`/bin/busybox mount 2>/dev/null`
  fi
  
  if [ "$MOUNTED" = "" ]; then
     /bin/busybox mkdir -p /proc    2>/dev/null
     /bin/busybox mount -n -t proc proc /proc    2>/dev/null
     /bin/busybox sync 2>/dev/null
     /bin/busybox mkdir -p /sys   2>/dev/null
     /bin/busybox mount -n -t sysfs sysfs /sys   2>/dev/null
     /bin/busybox sync 2>/dev/null
     /bin/busybox mount -o remount,rw -t rootfs rootfs /  2>/dev/null  
     /bin/busybox sync 2>/dev/null
     export ECHOTEXT="$ECHOTEXT
$INITPREF mount commands issued for procfs, sysfs, rootfs, continuing...."
  fi

  #  now prove the iffy cases
  if `is_not_string_in_file  "proc"  "/proc/mounts"`; then 
      /bin/busybox mount -n -t proc proc /proc    2>/dev/null
      if [ $? -ne 0 ]; then
        #echoconsole "$1" " unable to mount /proc ,retrying ...."
        /bin/busybox mkdir -p /proc    2>/dev/null
        /bin/busybox mount -n -t proc proc /proc    2>/dev/null
        if [ $? -ne 0 ]; then
          export ECHOTEXT="$ECHOTEXT 
$INITPREF unable to mount /proc: giving up." 
	        #error2ash "$1"
        fi
      else
        export ECHOTEXT="$ECHOTEXT 
$INITPREF ...procfs /proc is up and mounted" 
      fi 
  fi

  #
  if `is_not_string_in_file  "sysfs"  "/proc/mounts"`; then   
      /bin/busybox mount -n -t sysfs sysfs /sys   2>/dev/null
      if [ $? -ne 0 ]; then
        #3echoconsole "$1" " unable to mount /sys ,retrying ...."
        /bin/busybox mkdir -p /sys   2>/dev/null
        /bin/busybox mount -n -t sysfs sysfs /sys   2>/dev/null
        if [ $? -ne 0 ]; then
          export ECHOTEXT="$ECHOTEXT 
$INITPREF unable to mount /sys: giving up."
          #error2ash "$1"
        fi
      else
        export ECHOTEXT="$ECHOTEXT 
$INITPREF ...sysfs  /sys is up and mounted"
      fi
  fi

  if `is_not_string_in_file  "rootfs"  "/proc/mounts"`; then 
    # for the case rootfs in INITRAMFS is unaccessible or we forgot rw boot option 
	  /bin/busybox mount  -o remount,rw -t rootfs rootfs /  2>/dev/null   
	  if [ $? -ne 0 ]; then
      export ECHOTEXT="$ECHOTEXT 
$INITPREF unable to mount root / in  read-write mode!"
	  fi
  fi
}
#
mount_debugfs()
{
 local RC DEBUGFS
 if  `is_string_in_file  "debugfs"  "/proc/filesystems" `; then 
	/bin/busybox mkdir -p /sys/kernel  2>/dev/null
	/bin/busybox mkdir -p /sys/kernel/debug  2>/dev/null
	/bin/busybox mount -t debugfs  debugfs /sys/kernel/debug  2>/dev/null
	RC=$?
  export ECHOTEXT="$ECHOTEXT 
$INITPREF Mounted debugfs at /sys/kernel/debug with '$RC'...."
 else
  export ECHOTEXT="$ECHOTEXT 
$INITPREF Unable to mount debugfs, kernel misconfigured !"
 fi
}
#
mount_filesystems()
{
 mount_procfs_sysfs "$1"
 /bin/busybox sync 2>/dev/null
 # The debugfs feature is normally not needed in initial boot 
 if [ "$DEBUG" != "" -o "$DEBUGFS" != "" ]; then
  if  `is_not_string_in_file  "debugfs"  "/proc/mounts" `; then 
   mount_debugfs
   /bin/busybox sync 2>/dev/null
  fi
  #DEBUGFS=`/bin/busybox grep "debugfs" </proc/filesystems 2>/dev/null | /bin/busybox tr -d " \t" 2>/dev/null`
 fi
}
#
read_distrofiles()
{
  local SYSDISTRO
  if [ "$SUPPORTED_DISTROS" != "" ]; then
      for SYSDISTRO in "$SUPPORTED_DISTROS"; do
        SYSDISTRO="`echo $SYSDISTRO | /bin/busybox tr -d ' ' 2>/dev/null`"
        if [ -e DISTRO_SPECS.$SYSDISTRO ]; then
          source DISTRO_SPECS.$SYSDISTRO
          echoconsole "$0" "Distribution support for '$SYSDISTRO' loaded....."
          if [ -e $SYSDISTRO.vars ]; then
            source $SYSDISTRO.vars
          else
            echoconsole "$0" "No specific variables for '$SYSDISTRO' read..."
          fi
          if [ -e $SYSDISTRO.functions ]; then
            source $SYSDISTRO.functions
          else
            echoconsole "$0" "No specific functions for '$SYSDISTRO' read..."
          fi
        else
          echoconsole "$0" "Distribution '$SYSDISTRO' not supported, "
          echoconsole "$0" "or no special support necessary. Continuing without..."
        fi
      done
      return 0
  else
    echoconsole "$0" "No special distribution support enabled!"
    return 1
  fi
}
#
probe_for_kernelmodule_squashfs()
{
   # probe for a squashfs archive with kernel modules and mount if possible
   
  local FSYS
  FSYS=""
  # are the required file systems compiled into kernel or modules already loaded?
  FSYS="`/bin/busybox grep squashfs /proc/filesystems 2>/dev/null`"
  if [ "$FSYS" = "" ]; then
    echoconsole "$INITPREF" "no squashfs compiled in kernel '$KERNVER'"      
    echoconsole "$INITPREF" "or no kernel module squashfs loaded"      
    echoconsole "$INITPREF" "continuing without kernel modules from a squashfs...."      
    return 3
  fi
   
  if [ "$SQUASHFSEXT" = "" ]; then SQUASHFSEXT="sfs"; fi   
  export SQUASHFSEXT
  assign_kernver_signed_file "/" "$SQUASHFSEXT"
  
  if [ "$KERNVERFILE" != "" ]; then
    KERNELFILE="$KERNVERFILE"
  else
    echoconsole "$INITPREF" "no squashfs file with kernel modules found"      
    echoconsole "$INITPREF" "continuing without modules in a squashfs...."      
    return 4
    #FSYS="`/bin/busybox grep autofs /proc/filesystems 2>/dev/null`"  
  fi
   
  # install modules at standard place
  /bin/busybox mkdir -p /lib 2>/dev/null
  /bin/busybox mkdir -p /lib/modules 2>/dev/null
  /bin/busybox mkdir -p /lib/modules/$KERNVER 2>/dev/null
  /bin/busybox mkdir -p /lib/modules/$KERNVER/kernel 2>/dev/null
  # you definitely need compiled into kernel : 
  # squashfs with compression support, loop device support ,  to mount successfully 
  /bin/busybox mount -t squashfs -o loop,ro   $KERNELFILE   /lib/modules/$KERNVER/kernel 2>/dev/null
  RC=$?
  /bin/busybox sync  2>/dev/null
  if [ -e /lib/modules/$KERNVER/kernel/drivers ]; then
    echoconsole "$INITPREF" "Mounted '$KERNELFILE' with '$RC' "
    echoconsole "$INITPREF" "Directory for kernelmodules found at /lib/modules/$KERNVER/kernel/drivers"
  else
    # TODO: for now I don't know how to run unsquashfs in initramfs without lots of libraries  
    unsquashfs "$KERNELFILE" 2>/dev/null
    #RC=$?
    /bin/busybox sync  2>/dev/null
    #/bin/busybox rm  $KERNELFILE  2>/dev/null
    echoconsole "$INITPREF" " unsquashfs '$KERNELFILE' ended with '$RC' "
    if [ -e squashfs-root ]; then
     /bin/busybox mv -Rf squashfs-root/*  /lib/modules/$KERNVER/kernel/  2>/dev/null
     /bin/busybox rm -Rf squashfs-root  2>/dev/null
    else
      echoconsole "$INITPREF" "Failed to extract kernelmodules in '$KERNELFILE' with 'unsquashfs'!"
    fi
  fi
  /bin/busybox sync  2>/dev/null
  if  ! [  -e  /lib/modules/$KERNVER/kernel/drivers ]; then
    echoconsole "$INITPREF" "Failed to install kernelmodules '$KERNELFILES' at /lib/modules/$KERNVER/kernel !"
  fi
 #set +x

}
#
probe_for_kernelmodule_tarball()
{
  local LIBMODFILES LIBMODF
  LIBMODFILES=""
  LIBMODF=""
  # do not overwrite already mounted kernel module file or existent kernel modules
  if [ "`/bin/busybox ls -1 /lib/modules/$KERNVER/kernel  2>/dev/null`" = "" ]; then
    assign_kernver_signed_file "/" "tar.*"
	  if [ "$KERNVERFILE" != "" ]; then
      LIBMODF="$KERNVERFILE"
    else
      assign_kernver_signed_file "/" "tar.*" "libmodules"
      if [ "$KERNVERFILE" != "" ]; then
        LIBMODF="$KERNVERFILE"
      fi
    fi
    if [ "$LIBMODF" = "" ]; then
      LIBMDOFILES="libmodules*.tar.*"
      LIBMODFILES=`/bin/busybox ls -1 "$LIBMODFILES"  2>/dev/null`
      LIBMODF="libmodules-$KERNVER.tar.*"
      LIBMODF=`/bin/busybox ls -1 $LIBMODF   2>/dev/null`
    fi 
  fi
  # make the following scripts for module loading runnable - if we need some drivers..... 
  if [ "$LIBMODF" = "" ]; then
    # more than one and no current kernelversion in: take only the first one
    LIBMODF="$(echo $LIBMODFILES | /bin/busybox tr "\n" " " 2>/dev/null | /bin/busybox cut -f1 -d ' ' 2>/dev/null)"
  fi 
  if [ "$LIBMODF" != "" ]; then
    if [ -e "$LIBMODF" ]; then
      KERNELFILE="$LIBMODF"
      echoconsole  "$INITPREF" "extracting kernel modules from '$LIBMODF' ..."
      /bin/busybox tar -xf  $LIBMODF   2>/dev/null
      RC=$?
      /bin/busybox sync
      # clean up unused kernelmodules for other kernelversions
      #purge_unused_kernelmodules  "" "$INITPREF"    
      [ $RC -eq 0 ] && echoconsole  "$INITPREF" ".....done.  Continuing boot with these modules...."
      [ $RC -ne 0 ] && echoconsole  "$INITPREF" " Error! Extraction ended with '$RC' !"
    else
      echoconsole  "$INITPREF" " File '$LIBMODF' does not exist ! "
    fi
  else
    echoconsole  "$INITPREF" " No modules extracted, no file '$KERNVERFILE' found  !"
  fi
}
#
parse_rootdevice_string()
{
  local ROOTVAR
  UUID=""
  LABEL=""
  PARTUUID=""
  ROOTVAR="$(echo $ROOT | /bin/busybox tr [:upper:] [:lower:] 2>/dev/null )"
  if [ "$ROOTVAR" !="" ]; then
    case $ROOTVAR in
      ask|i|interactive)
        ROOTDEV="ask"
        check_dialog_equipment
        branch_2dialog        
      ;;
      # the Slackware, Puppylinux, .... cases
      /dev/hd*|/dev/sd*|/dev/sr*|/dev/mmcblk*|/dev/cdrom*|/dev/dvdrom*|/dev/cdram*|/dev/dvdram*)
        ROOTDEV=${ROOTVAR#/dev/}
      ;;
      hd*|sd*|sr*|mmcblk*|cdrom*|dvdrom*|cdram*|dvdram*)
        ROOTDEV="$ROOTVAR"
      ;;
      # the OpenSuSE,... cases
      /dev/disk/by-*/*)
        # assign UUID/LABEL content
        ROOTVAR=${ROOT#/dev/disk/by*/}
        # ROOT=LABEL or UUID  
        ROOT=${ROOT#/dev/disk/by-}
        # remove / and UUID/LABEL content from $ROOT
        ROOT=${ROOT%/*}  # | /bin/busybox cut -f1 -d "/"    2>/dev/null)"
        eval "$ROOT=\"$ROOTVAR\""
        export ROOT
        parse_rootdevice_string
      ;;
      #  the "id" and "name" cases do not work here for now
      #/dev/disk/by-id/*)
      #  export ROOT=ID=${ROOT#/dev/disk/by*/}
        #[ "$SUPPORTED_DISTROS" != "" ] &&  branch2_distro_support
      #;;
      #/dev/disk/by-name/*)
      #  export ROOT=NAME=${ROOT#/dev/disk/by*/}
        #[ "$SUPPORTED_DISTROS" != "" ] &&  branch2_distro_support
      #;;
      # the Redhat, Ubuntu,..., and generic cases
      label=*=uuid=*)
        LABEL=${ROOT#label=}
        #LABEL=${LABEL//=*} # | /bin/busybox cut -f2  -d "="    2>/dev/null)"
        UUID=${LABEL#*=uuid=} #"$(echo $ROOT | /bin/busybox cut -f3  -d "="    2>/dev/null)"
        LABEL=${LABEL//=*}    # | /bin/busybox cut -f2  -d "="    2>/dev/null)"
      ;;
      label=*,uuid=*)
        #LABEL="$(echo $ROOT | /bin/busybox cut -f2  -d "="    2>/dev/null| /bin/busybox cut -f1  -d ","    2>/dev/null)"
        #UUID="$(echo $ROOT  | /bin/busybox cut -f2-  -d ","    2>/dev/null | /bin/busybox cut -f1  -d "="    2>/dev/null)"
        UUID=${ROOT#label=*,uuid=}
        LABEL=${ROOT//,*}
        LABEL=${LABEL#label=}
      ;;
      uuid=*=label=*)
        UUID=${ROOT#uuid=}
        LABEL=${UUID#*=label=}
        UUID=${UUID//=*}
        #UUID="$(echo $ROOT | /bin/busybox cut -f2  -d "="    2>/dev/null)"
        #LABEL="$(echo $ROOT | /bin/busybox cut -f3  -d "="    2>/dev/null)"
      ;;
      uuid=*,label=*)
        UUID="$(echo $ROOT | /bin/busybox cut -f2  -d "="    2>/dev/null| /bin/busybox cut -f1  -d ","    2>/dev/null)"
        LABEL="$(echo $ROOT  | /bin/busybox cut -f2-  -d ","    2>/dev/null | /bin/busybox cut -f1  -d "="    2>/dev/null)"        
        LABEL=${ROOT#uuid=*,label=}
        UUID=${ROOT//,*}
        UUID=${UUID#uuid=}
      ;;
      label=*)
         LABEL=${ROOT#label=} #LABEL="$(echo $ROOT | /bin/busybox cut -f2-  -d "="    2>/dev/null)"
      ;;
      uuid=*)
        UUID=${ROOT#uuid=}
        #PARTUUID=$UUID
        #UUID="$(echo $ROOT | /bin/busybox cut -f2  -d "="    2>/dev/null| /bin/busybox cut -f1  -d ","    2>/dev/null)"
      ;;
      partuuid=*)
        PARTUUID=${ROOT#partuuid=}
        # cut out the characters after last "-" in string  
        UUID=${PARTUUID//*-}
        # allow maximal 16 (=22 decimal) partititons for PARTUUID, else switch to UUID interpretation
        if [ $(( 0x$UUID )) -ge 1 -a $(( 0x$UUID )) -le 22 ]; then  
          UUID="" 
        else
          UUID=$PARTUUID
        fi
      ;;
      # is there a shell variable specified before rootdevice's label or uuid declaration?
      *=label=*|*=uuid=*)
        #ROOTVAR="$(echo $ROOT | /bin/busybox cut -f1  -d "="  2>/dev/null)"
        #ROOT="$(echo $ROOT | /bin/busybox cut -f2-  -d "="   2>/dev/null)"
        # assign this variable and reparse
        ROOTVAR="$(echo ${ROOT//=*} | /bin/busybox tr [:lower:]  [:upper:]  2>/dev/null | /bin/busybox tr ".-" "_"  2>/dev/null)"
        ROOT=${ROOT#*=}
        eval "$ROOTVAR=\"$ROOT\"" 
        if [ "$ROOT" != "" ]; then
          export ROOT
          parse_rootdevice_string
        fi
      ;;
    esac
    #[ "$ROOTDEV" != "" ] && boot_device_check
    export  ROOTDEV LABEL UUID PARTUUID
  #else
  #  ROOT="ask"
  #  check_dialog_equipment
  #  branch_2dialog
  fi
  
}
#
# under construction
recognize_rootdevice()
{
  local var BLKID DEVBOOT DEVROOT DEVROOT2
  
  parse_rootdevice_string
  BLKID=""
  DEVBOOT=""
  DEVROOT=""
  DEVROOT2=""
  if [ "$ROOTDEV" != "" ]; then
    DEVROOT=""
    if [ "$PARTUUID" != "" ]; then
      BLKID=`get_partuuids`
      UID=${PARTUUID//-*}
      DEVROOT=`echo $BLKID | /bin/busybox grep "$UID" 2>/dev/null | /bin/busybox cut -f1 -d"|" 2>/dev/null`
      export ROOTDEV="$DEVROOT${PARTUUID#*-}"
      BLKID=`/bin/busybox blkid 2>/dev/null`
      DEVROOT=`echo $BLKID | /bin/busybox grep "$ROOTDEV" 2>/dev/null`
      TYPE=""
      for var in $DEVROOT; do
        case $var in
          *=*)
            eval "$var"
            if [ "$TYPE" != "" ]; then
               export ROOTDEVTYPE="$TYPE"
            fi 
          ;;
        esac
      done
    fi
    if [ "$DEVROOT" = "" ]; then
      DEVROOT2=""
      if [ "$LABEL" != "" -o "$UUID" != "" ]; then
        [ "$BLKID" != "" ] || BLKID=`/bin/busybox blkid 2>/dev/null`
        if [ "$LABEL" != "" ]; then
          DEVROOT=`echo $BLKID | /bin/busybox grep "LABEL=\"$LABEL\"" 2>/dev/null`
          TYPE=""
          for var in $DEVROOT; do
            case $var in
              *=*)
                eval "$var"
                if [ "$TYPE" != "" ]; then
                   export ROOTDEVTYPE="$TYPE"
                fi 
              ;;
              /*/*:)
                DEVBOOT=${var//:*}
              ;;
            esac
          done
        fi #LABEL
        if [ "$UUID" != "" ]; then
          DEVROOT2=`echo $BLKID | /bin/busybox grep "UUID=\"$UUID\"" 2>/dev/null `
          TYPE=""
          for var in $DEVROOT2; do
            case $var in
              *=*)
                eval "$var"
                if [ "$TYPE" != "" ]; then
                   export ROOTDEVTYPE="$TYPE"
                fi 
              ;;
              /*/*:)
                if [ "$DEVBOOOT" != "" ]; then
                  if [  "$DEVBOOT" != "${var//:*}" ]; then
                    return 4;
                  fi
                else
                  DEVBOOT=${var//:*}
                fi
              ;;
            esac
          done
        fi #UUID
      fi # label & uuid    
    fi #devroot
    if [ "$DEVBOOT" != "" ]; then
      export ROOTDEV="$DEVBOOT"
    else
      export ROOTDEV
    fi
    return 0
  else  # rootdev
    return 255
  fi  #rootdev
  
  if [ "$BOOT" != "" ]; then
   return 0
  else
   return 0
  fi
    
}
#
# under construction
check_dialog_equipment()
{
  return 0
}
#
# under construction
branch2_dialog()
{
  return 0
}
#
echoconsole "[ initsys-functions ]:" "read in!"    
#
